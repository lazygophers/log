name: 'Smart Cache'
description: 'Conditional caching - uses local cache for self-hosted runners, GitHub cache for hosted runners'
inputs:
  path:
    description: 'Path to cache'
    required: true
  key:
    description: 'Cache key'
    required: true
  restore-keys:
    description: 'Restore keys for fallback'
    required: false
    default: ''
  cache-dir:
    description: 'Local cache directory for self-hosted runners'
    required: false
    default: '/tmp/action'

outputs:
  cache-hit:
    description: 'Whether cache was hit'
    value: ${{ steps.check-cache.outputs.cache-hit }}

runs:
  using: 'composite'
  steps:
    - name: Detect runner type
      id: detect-runner
      shell: bash
      run: |
        # 检测是否为自建 runner
        # 方法1: 检查 RUNNER_NAME 是否包含 lazy
        # 方法2: 检查是否存在特定的自建标识文件
        # 方法3: 检查 GITHUB_ACTIONS_RUNNER_CONTEXT

        IS_SELF_HOSTED="false"

        # 检查 runner 名称
        if [[ "${RUNNER_NAME:-}" == *"lazy"* ]]; then
          IS_SELF_HOSTED="true"
        fi

        # 检查环境变量
        if [[ "${RUNNER_ENVIRONMENT:-}" == "self-hosted" ]]; then
          IS_SELF_HOSTED="true"
        fi

        # 检查特定标识文件（可选，在自建 runner 上创建此文件）
        if [[ -f "/etc/github-runner/self-hosted" ]]; then
          IS_SELF_HOSTED="true"
        fi

        echo "is-self-hosted=$IS_SELF_HOSTED" >> $GITHUB_OUTPUT
        echo "Runner type: $([ "$IS_SELF_HOSTED" = "true" ] && echo "self-hosted" || echo "github-hosted")"

    - name: Validate and normalize cache path
      id: validate-path
      shell: bash
      run: |
        # 验证并规范化缓存路径，防止路径遍历攻击
        INPUT_PATH="${{ inputs.path }}"
        
        # 获取绝对路径
        ABSOLUTE_PATH=$(realpath -m "${INPUT_PATH}" 2>/dev/null || echo "${INPUT_PATH}")
        
        # 检查路径是否包含可疑字符或模式
        if [[ "${INPUT_PATH}" == *".."* ]] || [[ "${INPUT_PATH}" == *"~"* ]]; then
          echo "Error: Path contains invalid characters or patterns"
          echo "valid-path=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # 允许 Go 标准缓存路径（GOMODCACHE 和 GOCACHE）
        # 这些路径通常在用户主目录或系统目录下
        WORKSPACE_DIR="${GITHUB_WORKSPACE}"
        HOME_DIR="${HOME}"
        
        # 检查是否为 Go 标准缓存路径
        IS_GO_CACHE="false"
        if [[ "${ABSOLUTE_PATH}" == *"/go/pkg/mod"* ]] || [[ "${ABSOLUTE_PATH}" == *"/go-build"* ]]; then
          IS_GO_CACHE="true"
        fi
        
        # 验证路径在允许的范围内
        if [[ "${IS_GO_CACHE}" == "true" ]]; then
          # Go 缓存路径允许在任何位置（通常在用户主目录下）
          echo "Path is a Go cache directory, allowing"
          echo "valid-path=true" >> $GITHUB_OUTPUT
        elif [[ "${ABSOLUTE_PATH}" != "${WORKSPACE_DIR}"* ]] && [[ "${ABSOLUTE_PATH}" != "${HOME_DIR}"* ]]; then
          echo "Error: Path must be within workspace or home directory"
          echo "valid-path=false" >> $GITHUB_OUTPUT
          exit 1
        else
          echo "Path is within allowed directories"
          echo "valid-path=true" >> $GITHUB_OUTPUT
        fi
        
        echo "normalized-path=${ABSOLUTE_PATH}" >> $GITHUB_OUTPUT

    - name: Setup local cache directory
      if: steps.validate-path.outputs.valid-path == 'true' && steps.detect-runner.outputs.is-self-hosted == 'true'
      shell: bash
      env:
        CACHE_DIR: ${{ inputs.cache-dir }}
      run: |
        mkdir -p "$CACHE_DIR"
        echo "Local cache directory: $CACHE_DIR"

    - name: Generate cache paths
      id: cache-paths
      if: steps.validate-path.outputs.valid-path == 'true'
      shell: bash
      env:
        CACHE_DIR: ${{ inputs.cache-dir }}
        CACHE_KEY: ${{ inputs.key }}
      run: |
        # 为本地缓存生成路径
        CACHE_PATH="$CACHE_DIR/$CACHE_KEY"

        echo "local-cache-path=${CACHE_PATH}" >> $GITHUB_OUTPUT
        echo "cache-key=${CACHE_KEY}" >> $GITHUB_OUTPUT

    - name: Check local cache
      if: steps.validate-path.outputs.valid-path == 'true' && steps.detect-runner.outputs.is-self-hosted == 'true'
      id: local-cache-check
      shell: bash
      run: |
        CACHE_PATH="${{ steps.cache-paths.outputs.local-cache-path }}"
        CACHE_HIT="false"

        if [[ -f "${CACHE_PATH}.tar.gz" ]]; then
          echo "Local cache found: ${CACHE_PATH}.tar.gz"

          # 检查目标目录是否已存在且有内容
          if [[ -d "${{ steps.validate-path.outputs.normalized-path }}" ]] && [[ "$(ls -A "${{ steps.validate-path.outputs.normalized-path }}" 2>/dev/null)" ]]; then
            echo "Cache directory already exists and has content, skipping extraction"
            CACHE_HIT="true"
          else
            echo "Extracting cache..."
            TARGET_DIR="$(dirname "${{ steps.validate-path.outputs.normalized-path }}")"
            cd "$TARGET_DIR"

            # 解压缓存
            if tar -xzf "${CACHE_PATH}.tar.gz" -C . 2>/dev/null; then
              echo "Cache extracted successfully"
              CACHE_HIT="true"
            else
              echo "Cache extraction failed, but cache file exists"
              # 即使解压失败，如果目标目录存在，也认为是缓存命中
              if [[ -d "$(basename "${{ steps.validate-path.outputs.normalized-path }}")" ]]; then
                echo "Target directory exists, treating as cache hit"
                CACHE_HIT="true"
              else
                CACHE_HIT="false"
              fi
            fi
          fi
        else
          echo "No local cache found: ${CACHE_PATH}.tar.gz"
        fi

        echo "cache-hit=${CACHE_HIT}" >> $GITHUB_OUTPUT

    - name: GitHub Actions Cache (for hosted runners)
      if: steps.validate-path.outputs.valid-path == 'true' && steps.detect-runner.outputs.is-self-hosted == 'false'
      id: github-cache
      uses: actions/cache@v4
      with:
        path: ${{ steps.validate-path.outputs.normalized-path }}
        key: ${{ inputs.key }}
        restore-keys: ${{ inputs.restore-keys }}

    - name: Set final cache result
      id: check-cache
      shell: bash
      run: |
        if [[ "${{ steps.detect-runner.outputs.is-self-hosted }}" == "true" ]]; then
          CACHE_HIT="${{ steps.local-cache-check.outputs.cache-hit }}"
        else
          CACHE_HIT="${{ steps.github-cache.outputs.cache-hit }}"
        fi

        echo "cache-hit=${CACHE_HIT}" >> $GITHUB_OUTPUT
        echo "Final cache result: ${CACHE_HIT}"

    - name: Save local cache (post-job)
      if: steps.validate-path.outputs.valid-path == 'true' && steps.detect-runner.outputs.is-self-hosted == 'true' && always()
      shell: bash
      run: |
        # 这个步骤在 post-job 中运行，保存缓存
        CACHE_PATH="${{ steps.cache-paths.outputs.local-cache-path }}"

        if [[ -d "${{ steps.validate-path.outputs.normalized-path }}" ]] && [[ "${{ steps.local-cache-check.outputs.cache-hit }}" != "true" ]]; then
          echo "Saving local cache..."
          mkdir -p "$(dirname "${CACHE_PATH}")"

          cd "$(dirname "${{ steps.validate-path.outputs.normalized-path }}")"
          tar -czf "${CACHE_PATH}.tar.gz" "$(basename "${{ steps.validate-path.outputs.normalized-path }}")"

          if [[ $? -eq 0 ]]; then
            echo "Cache saved successfully: ${CACHE_PATH}.tar.gz"
          else
            echo "Failed to save cache"
          fi
        fi